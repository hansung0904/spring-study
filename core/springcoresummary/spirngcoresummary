회원 도메인 설계의 문제점
    -> 이 코드의 설계상 문제점은 무엇인가?
    -> 다른 저장소로 변경할 때 OCP 원칙을 잘 준수할까?
    -> DIP를 잘 지키고 있을까요?
    -> 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음.
        ->> 주문까지 만들고나서 다시 한 번 해결방안을 모색해보자.

새로운 할인 정책 개발
    -> 새로운 할인 정책을 확장해보자

    -> 기획자 : 서비스 오픈 직전에 할인 정책을 바꾸려고한다.
    -> 개발자 : 처음부터 고정 할인 금액은 아니라고 함
    -> 기획자 : 애자일 소프트웨어 개발 선언 몰라요 ? "계획을 따르다기보다 변화에 대응하기를"
    -> 개발자 : ...(유연한 설계가 가능하도록 객체지향 원칙을 준수함 ㅅㄱ ㅋㅋ)

방금 추가한 할인 정책을 어플리케이션에 적용해보도록 하자.

관심사의 분리
    -> 애플리케이션을 하나의 공연이라고 생각해보자 각각의 인터페이스를 배역이라 생각해보자 그런데! 실제 배역에 맞는 배우를
       선택하는 것은 누가하나?
    -> 로미오와 줄리엣 공연을 하면 로미오 역할을 누가 할지 줄리엣 역할을 누가 할지는 배우들이 정하는게 아니다.
    -> 이전 코드는 마치 로미오 역할을 하는(인터페이스) 레오나르도 디카프리오 (구현체,배우)가 줄리엣 역할(인터페이스)을 하는 여자 주인공(구현체, 배우)
       을 직접 초빙하는것과 같다. 디카프리오는 공연도 해야하고 동시에 여자 주인공도 공연에 직접 초빙해야하는 *다양한 책임*을 가지고 있다.

       **관심사를 분리하자**
    -> 배우는 본인의 역할인 배역을 수행하는 것에만 집중해야 한다.
    -> 디카프리오는 어떤 여자 주인공이 선택되더라도 똑같이 공연을 할 수 있어야 한다.
    -> 공연을 구성하고, 담당 배우를 섭외하고, 역할에 맞는 배우를 지정하는 책임을 담당하는 별도의 *공연 기획자*가 나올시점임.
    -> 공연 기획자를 만들고, 배우와 공연 기획자의 책임을 확실히 분리해보도록하자.

AppConfig의 등장
    -> 애플리케이션의 전체 동작 방식을 구성(config)하기 위해 *구현객체를생성*하고 *연결*하는 책임을 가지는 별도의 설정 클래스를 만들자.

정리
    -> AppConfig를 통해서 관심사를 확실하게 분리했다.
    -> 배역, 배우를 생각해보자
    -> AppConfig는 공연 기획자이다.
    -> AppConfig는 구체 클래스를 선택한다. 배역에 맞는 담당 배우를 선택한다. 애플리케이션이 어떻게 동작해야 할지 전체 구성을 책임진다.
    -> 이제 각 배우들은 담당 기능을 실행하는 책임만 지면 된다.
    -> OrderServiceImpl 은 기능을 실행하는 책임만 지면 된다.



